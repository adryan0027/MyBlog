{
  "hash": "71936eeebe7c130982308b59abcd02b6",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Atividade 3- Regressão linear\"\nauthor: \"Adryan Saraiva\"\ndate: \"2025-11-23\"\ncategories: [api, code, python, correios, json]\nimage: \"grafico_regressao.png\"\n---\n\nNeste post eu mostro como criar uma Regressão linear em *python*, onde aparece informações do grafico de forma linear.\n\n::: {#5b2d588d .cell execution_count=1}\n``` {.python .cell-code}\nimport os\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom IPython.display import Image, display\n\n# Caminhos dos arquivos enviados — prioriza os arquivos locais do post\nfrom pathlib import Path\nbase = Path.cwd()\nX_path = base / \"X.txt\"\ny_path = base / \"y.txt\"\n\n# Suporte opcional ao /mnt/data (por exemplo quando executado em alguns ambientes)\nif not X_path.exists():\n    alt = Path(\"/mnt/data\") / \"X.txt\"\n    if alt.exists():\n        X_path = alt\nif not y_path.exists():\n    alt = Path(\"/mnt/data\") / \"y.txt\"\n    if alt.exists():\n        y_path = alt\n\nprint(\"CWD:\", os.getcwd())\nprint(\"X.txt exists:\", os.path.exists(X_path))\nprint(\"y.txt exists:\", os.path.exists(y_path))\n\n# ----- Leitura -----\nif X_path.exists() and y_path.exists():\n    X = np.loadtxt(str(X_path))\n    y = np.loadtxt(str(y_path))\nelse:\n    print(\"Arquivos não encontrados — usando fallback constante.\")\n    X = np.full(50, 4.6317925681770316)\n    y = np.full_like(X, 12439.153947498304)\n\nX = np.asarray(X).ravel()\ny = np.asarray(y).ravel()\n\n# Se os vetores tiverem tamanhos diferentes, truncar para o menor tamanho\nif X.size != y.size:\n    minlen = min(X.size, y.size)\n    print(f\"Tamanhos diferentes: X={X.size}, y={y.size}. Truncando para {minlen}.\")\n    X = X[:minlen]\n    y = y[:minlen]\n\nprint(\"shapes:\", X.shape, y.shape)\n\n# ----- Regressão -----\nif np.isclose(np.var(X), 0):\n    intercepto = float(np.mean(y))\n    inclinacao = 0.0\nelse:\n    X_mat = np.vstack([np.ones_like(X), X]).T\n    beta = np.linalg.lstsq(X_mat, y, rcond=None)[0]\n    intercepto, inclinacao = float(beta[0]), float(beta[1])\n\n# ----- Gráfico -----\ndf = pd.DataFrame({\"x\": X, \"y\": y})\nfig, ax = plt.subplots(figsize=(8, 4.5))\nax.scatter(df[\"x\"], df[\"y\"], label=\"Dados\")\n\nx_line = np.linspace(df[\"x\"].min(), df[\"x\"].max(), 200)\nax.plot(x_line, intercepto + inclinacao * x_line, color=\"red\", label=\"Ajuste\")\n\nax.set_xlabel(\"x\")\nax.set_ylabel(\"y\")\nax.legend()\nfig.tight_layout()\nfig.savefig(\"grafico_regressao.png\", dpi=150, bbox_inches='tight')\n# Fecha a figura para evitar que o ambiente (Jupyter/Quarto) também a renderize\nplt.close(fig)\n\nprint(f\"Intercepto: {intercepto:.4f}\")\nprint(f\"Inclinação: {inclinacao:.4f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCWD: /workspaces/myblog/posts/grafico linear\nX.txt exists: True\ny.txt exists: True\nTamanhos diferentes: X=700, y=697. Truncando para 697.\nshapes: (697,) (697,)\nIntercepto: 346.2344\nInclinação: 997.6642\n```\n:::\n:::\n\n\n![Gráfico de regressão](grafico_regressao.png)\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}