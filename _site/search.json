[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "myblog",
    "section": "",
    "text": "Atividade 2- API SPTRANS\n\n\n\napi\n\ncode\n\npython\n\ncorreios\n\njson\n\n\n\n\n\n\n\n\n\nNov 23, 2025\n\n\nAdryan Saraiva\n\n\n\n\n\n\n\n\n\n\n\n\nAtividade 1- Cotação dolar\n\n\n\napi\n\ncode\n\npython\n\ncorreios\n\njson\n\n\n\n\n\n\n\n\n\nNov 23, 2025\n\n\nAdryan Saraiva\n\n\n\n\n\n\n\n\n\n\n\n\nAtividade 3- Regressão linear\n\n\n\napi\n\ncode\n\npython\n\ncorreios\n\njson\n\n\n\n\n\n\n\n\n\nNov 23, 2025\n\n\nAdryan Saraiva\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/post-with-code/index.html",
    "href": "posts/post-with-code/index.html",
    "title": "Atividade 1- Cotação dolar",
    "section": "",
    "text": "Neste post eu mostro como criar uma pesquisa em python um site, onde aparece informações das cotações em dolar em uma determinada época em forma de gráfico.\n\nimport pandas as pd\nimport requests\nimport calendar\nfrom datetime import datetime\nimport plotly.express as px\n\ndef cotacao_dolar_periodo(mmyyyy: str):\n    \"\"\"\n    Recebe uma string no formato 'MMYYYY' e retorna\n    um gráfico de linha com as cotações diárias do dólar PTAX.\n    \"\"\"\n\n    first_date = datetime.strptime(mmyyyy, \"%m%Y\")\n    last_date = first_date.replace(\n        day = calendar.monthrange(first_date.year, first_date.month)[1]\n    )\n\n    data_ini = first_date.strftime(\"%m-%d-%Y\")\n    data_fim = last_date.strftime(\"%m-%d-%Y\")\n\n    url = (\n        \"https://olinda.bcb.gov.br/olinda/servico/PTAX/versao/v1/odata/\"\n        \"CotacaoDolarPeriodo(dataInicial=@dataInicial,dataFinalCotacao=@dataFinalCotacao)\"\n        f\"?@dataInicial='{data_ini}'&@dataFinalCotacao='{data_fim}'\"\n        \"&$top=100&$format=json\"\n    )\n\n    # 3  Requisição\n    response = requests.get(url)\n    dados = response.json()[\"value\"]\n\n    df = pd.DataFrame(dados)\n    df[\"data\"] = pd.to_datetime(df[\"dataHoraCotacao\"]).dt.date\n    df = df[[\"data\", \"cotacaoCompra\", \"cotacaoVenda\"]]\n\n    # 5  Remover duplicados e ordenar\n    df = df.groupby(\"data\").mean().reset_index()\n    df = df.sort_values(\"data\")\n\n    # 6  Preencher feriados e finais de semana (forward-fill)\n    idx = pd.date_range(start=first_date, end=last_date)\n    df = df.set_index(\"data\").reindex(idx)\n    df = df.fillna(method=\"ffill\")\n    df.index.name = \"data\"\n    df = df.reset_index()\n\n    # 7  Plotly\n    fig = px.line(\n        df,\n        x=\"data\",\n        y=\"cotacaoVenda\",\n        title=f\"Cotação do Dólar  {mmyyyy[:2]}/{mmyyyy[2:]}\",\n        labels={\"cotacaoVenda\": \"Cotação (Venda)\", \"data\": \"Data\"}\n    )\n\n    fig.update_layout(yaxis_tickformat=\".2f\")\n    return fig\n\n# Executando para sua data 01/2010\ncotacao_dolar_periodo(\"012010\")\n\n/tmp/ipykernel_29258/4176580709.py:43: FutureWarning:\n\nDataFrame.fillna with 'method' is deprecated and will raise in a future version. Use obj.ffill() or obj.bfill() instead."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "This is the first post in a Quarto blog. Welcome!\n\nSince this post doesn’t specify an explicit image, the first image in the post will be used in the listing page of posts."
  },
  {
    "objectID": "posts/onibus terminal/index.html",
    "href": "posts/onibus terminal/index.html",
    "title": "Atividade 2- API SPTRANS",
    "section": "",
    "text": "Neste post eu mostro uma pesquisapython utilizando uma API, onde aparece as rotas de onibus e paradas\n\nimport os\nimport requests\nfrom dotenv import load_dotenv\nfrom IPython.display import HTML, display\nimport folium\nimport math\n\nload_dotenv()\ntoken = os.getenv(\"SPTRANS_TOKEN\")\n\ns = requests.Session()\n\ndemo_paradas = [\n    {\"cp\": 7014417, \"np\": \"ANGELICA B/C\", \"ed\": \"AV ANGELICA\", \"py\": -23.534564, \"px\": -46.654302},\n    {\"cp\": 60016784, \"np\": \"PARADA PALMEIRAS B/C\", \"ed\": \"R PADRE ANTONIO TOMAS\", \"py\": -23.525799, \"px\": -46.679251},\n    {\"cp\": 60016786, \"np\": \"ANTARTICA B/C\", \"ed\": \"PC SOUSA ARANHA\", \"py\": -23.526523, \"px\": -46.673588},\n    {\"cp\": 12783, \"np\": \"PARADA D\", \"ed\": \"R EXEMPLO\", \"py\": -23.535317, \"px\": -46.653005},\n]\n\ndemo_pos = [\n    {\"p\": \"12783\", \"ta\": \"2024-09-27T01:05:47Z\", \"py\": -23.53531725, \"px\": -46.653005},\n    {\"p\": \"12534\", \"ta\": \"2024-09-27T01:06:10Z\", \"py\": -23.547649, \"px\": -46.6410115},\n]\n\ndef fetch_paradas_pos(codigo_linha=2506):\n    \"\"\"Tenta buscar paradas e posições da API; retorna (paradas, pos_list).\n    Em caso de erro ou token ausente, retorna dados de demonstração.\"\"\"\n    if not token:\n        print(\"SPTRANS_TOKEN não encontrado — usando dados de demonstração.\")\n        return demo_paradas, demo_pos\n\n    try:\n        auth = s.post(f\"https://api.olhovivo.sptrans.com.br/v2.1/Login/Autenticar?token={token}\", timeout=10)\n        print(\"Login response:\", auth.text)\n\n        r_par = s.get(f\"https://api.olhovivo.sptrans.com.br/v2.1/Parada/BuscarParadasPorLinha?codigoLinha={codigo_linha}\", timeout=10)\n        paradas = r_par.json()\n\n        r_pos = s.get(f\"https://api.olhovivo.sptrans.com.br/v2.1/Posicao/Linha?codigoLinha={codigo_linha}\", timeout=10)\n        pos_json = r_pos.json()\n        pos_list = pos_json.get(\"vs\") if isinstance(pos_json, dict) else []\n\n        if not paradas:\n            print(\"API retornou 0 paradas — usando dados de demonstração.\")\n            return demo_paradas, demo_pos\n\n        return paradas, pos_list\n\n    except Exception as e:\n        print(\"Erro ao acessar API Olho Vivo:\", e)\n\n        return demo_paradas, demo_pos\n\n\nparadas, pos_list = fetch_paradas_pos(codigo_linha=2506)\n\nprint(f\"Usando {len(paradas)} paradas e {len(pos_list)} posições (veículos).\")\n\ndef mean_center(points):\n    lat = [p[\"py\"] for p in points]\n    lon = [p[\"px\"] for p in points]\n    return (sum(lat) / len(lat), sum(lon) / len(lon))\n\ncenter = mean_center(paradas) if paradas else (-23.534564, -46.654302)\n\nm = folium.Map(location=center, zoom_start=14)\n\nfor p in paradas:\n    folium.Marker(location=[p[\"py\"], p[\"px\"]], popup=f\"{p.get('np')}\\n{p.get('ed','')}\").add_to(m)\n\nfor v in pos_list:\n    try:\n        folium.CircleMarker(location=[v[\"py\"], v[\"px\"]], radius=6, color=\"red\", fill=True, fill_opacity=0.8,\n                            popup=f\"Veículo: {v.get('p')}\\nHora: {v.get('ta')}\").add_to(m)\n    except Exception:\n        pass\n\noutput = f\"paradas_linha_2506.html\"\nm.save(output)\nprint(f\"Mapa salvo em: {output}\")\n\ndisplay(HTML(m._repr_html_()))\n\nLogin response: true\nUsando 15 paradas e 1 posições (veículos).\nMapa salvo em: paradas_linha_2506.html\n\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook"
  },
  {
    "objectID": "posts/dolar/index.html",
    "href": "posts/dolar/index.html",
    "title": "Atividade 1- Cotação dolar",
    "section": "",
    "text": "Neste post eu mostro como criar uma pesquisa em python um site, onde aparece informações das cotações em dolar em uma determinada época em forma de gráfico.\n\nimport pandas as pd\nimport requests\nimport calendar\nfrom datetime import datetime\nimport plotly.express as px\n\ndef cotacao_dolar_periodo(mmyyyy: str):\n    \"\"\"\n    Recebe uma string no formato 'MMYYYY' e retorna\n    um gráfico de linha com as cotações diárias do dólar PTAX.\n    \"\"\"\n\n    first_date = datetime.strptime(mmyyyy, \"%m%Y\")\n    last_date = first_date.replace(\n        day = calendar.monthrange(first_date.year, first_date.month)[1]\n    )\n\n    data_ini = first_date.strftime(\"%m-%d-%Y\")\n    data_fim = last_date.strftime(\"%m-%d-%Y\")\n\n    url = (\n        \"https://olinda.bcb.gov.br/olinda/servico/PTAX/versao/v1/odata/\"\n        \"CotacaoDolarPeriodo(dataInicial=@dataInicial,dataFinalCotacao=@dataFinalCotacao)\"\n        f\"?@dataInicial='{data_ini}'&@dataFinalCotacao='{data_fim}'\"\n        \"&$top=100&$format=json\"\n    )\n\n    # 3  Requisição\n    response = requests.get(url)\n    dados = response.json()[\"value\"]\n\n    df = pd.DataFrame(dados)\n    df[\"data\"] = pd.to_datetime(df[\"dataHoraCotacao\"]).dt.date\n    df = df[[\"data\", \"cotacaoCompra\", \"cotacaoVenda\"]]\n\n    # 5  Remover duplicados e ordenar\n    df = df.groupby(\"data\").mean().reset_index()\n    df = df.sort_values(\"data\")\n\n    # 6  Preencher feriados e finais de semana (forward-fill)\n    idx = pd.date_range(start=first_date, end=last_date)\n    df = df.set_index(\"data\").reindex(idx)\n    df = df.fillna(method=\"ffill\")\n    df.index.name = \"data\"\n    df = df.reset_index()\n\n    # 7  Plotly\n    fig = px.line(\n        df,\n        x=\"data\",\n        y=\"cotacaoVenda\",\n        title=f\"Cotação do Dólar  {mmyyyy[:2]}/{mmyyyy[2:]}\",\n        labels={\"cotacaoVenda\": \"Cotação (Venda)\", \"data\": \"Data\"}\n    )\n\n    fig.update_layout(yaxis_tickformat=\".2f\")\n    return fig\n\n# Executando para sua data 01/2010\ncotacao_dolar_periodo(\"012010\")\n\n/tmp/ipykernel_67660/4176580709.py:43: FutureWarning:\n\nDataFrame.fillna with 'method' is deprecated and will raise in a future version. Use obj.ffill() or obj.bfill() instead."
  },
  {
    "objectID": "posts/grafico linear/index.html",
    "href": "posts/grafico linear/index.html",
    "title": "Atividade 3- Regressão linear",
    "section": "",
    "text": "Neste post eu mostro como criar uma Regressão linear em python, onde aparece informações do grafico de forma linear.\n\nimport os\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom IPython.display import Image, display\n\n# Caminhos dos arquivos enviados — prioriza os arquivos locais do post\nfrom pathlib import Path\nbase = Path.cwd()\nX_path = base / \"X.txt\"\ny_path = base / \"y.txt\"\n\n# Suporte opcional ao /mnt/data (por exemplo quando executado em alguns ambientes)\nif not X_path.exists():\n    alt = Path(\"/mnt/data\") / \"X.txt\"\n    if alt.exists():\n        X_path = alt\nif not y_path.exists():\n    alt = Path(\"/mnt/data\") / \"y.txt\"\n    if alt.exists():\n        y_path = alt\n\nprint(\"CWD:\", os.getcwd())\nprint(\"X.txt exists:\", os.path.exists(X_path))\nprint(\"y.txt exists:\", os.path.exists(y_path))\n\n# ----- Leitura -----\nif X_path.exists() and y_path.exists():\n    X = np.loadtxt(str(X_path))\n    y = np.loadtxt(str(y_path))\nelse:\n    print(\"Arquivos não encontrados — usando fallback constante.\")\n    X = np.full(50, 4.6317925681770316)\n    y = np.full_like(X, 12439.153947498304)\n\nX = np.asarray(X).ravel()\ny = np.asarray(y).ravel()\n\n# Se os vetores tiverem tamanhos diferentes, truncar para o menor tamanho\nif X.size != y.size:\n    minlen = min(X.size, y.size)\n    print(f\"Tamanhos diferentes: X={X.size}, y={y.size}. Truncando para {minlen}.\")\n    X = X[:minlen]\n    y = y[:minlen]\n\nprint(\"shapes:\", X.shape, y.shape)\n\n# ----- Regressão -----\nif np.isclose(np.var(X), 0):\n    intercepto = float(np.mean(y))\n    inclinacao = 0.0\nelse:\n    X_mat = np.vstack([np.ones_like(X), X]).T\n    beta = np.linalg.lstsq(X_mat, y, rcond=None)[0]\n    intercepto, inclinacao = float(beta[0]), float(beta[1])\n\n# ----- Gráfico -----\ndf = pd.DataFrame({\"x\": X, \"y\": y})\nfig, ax = plt.subplots(figsize=(8, 4.5))\nax.scatter(df[\"x\"], df[\"y\"], label=\"Dados\")\n\nx_line = np.linspace(df[\"x\"].min(), df[\"x\"].max(), 200)\nax.plot(x_line, intercepto + inclinacao * x_line, color=\"red\", label=\"Ajuste\")\n\nax.set_xlabel(\"x\")\nax.set_ylabel(\"y\")\nax.legend()\nfig.tight_layout()\nfig.savefig(\"grafico_regressao.png\", dpi=150, bbox_inches='tight')\n# Fecha a figura para evitar que o ambiente (Jupyter/Quarto) também a renderize\nplt.close(fig)\n\nprint(f\"Intercepto: {intercepto:.4f}\")\nprint(f\"Inclinação: {inclinacao:.4f}\")\n\nCWD: /workspaces/myblog/posts/grafico linear\nX.txt exists: True\ny.txt exists: True\nTamanhos diferentes: X=700, y=697. Truncando para 697.\nshapes: (697,) (697,)\nIntercepto: 346.2344\nInclinação: 997.6642\n\n\n\n\n\nGráfico de regressão"
  }
]